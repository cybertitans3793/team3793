package org.usfirst.frc.team3793.robot;

//all imports below
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.vision.*;
import edu.wpi.first.wpilibj.Ultrasonic;
//import edu.wpi.first.wpilibj.image.*;
//import edu.wpi.first.wpilibj.interfaces.*;

public class Robot extends IterativeRobot {

	/**
	 * Has the button to move the piston been released since the last state change
	 */
	private boolean hasReleased = true;
	private boolean hasHappened = true;
	public Joystick pistonJoystick = new Joystick(0);
	public Joystick driveJoystick = new Joystick (1);
	public Solenoid solenoid = new Solenoid(0);
	public Solenoid theNoodler = new Solenoid  (1); //the arm that grabs the pool noodles
	public Compressor compressor = new Compressor(0); 
	//public Talon talon1 = new Talon(0);
   //public  //IP o f the camera
	static public Timer time = new Timer (); //time functions
	public RobotDrive drive = new RobotDrive (0, 1); //arguments are the channels for the Left and Right motors
	
	
	//------BUTTONS--------  (should be 1-#OfButtons)
	/**the button index used for toggling the piston state*/
	private final int pistonToggle = 1;
	/**value higher higher than one 1*/
	private double speedOfMotor =  1; //value higher than 1

	public void disabledInit()
	{
		//AxisCamera camera = new AxisCamera("10.37.93.15");
    	//Timer.delay(8.0);
    	//System.out.println("camera connected (supposedly)");
	}
	//This function below run once when robot starts 
    public void robotInit() 
    {
    	compressor.start();
        //accel.free ();
        time.reset ();
    }
    
    //This function is called periodically during autonomous
    public void autonomousPeriodic() { 
    
    }
 
    
    //This function is called every 20 milliseconds approximately during operator control
    
    public double lastY = 0.0;
    public double currY = 0.0;
    public void teleopPeriodic() { 
    	
    	
    	//CODE BELOW IS FOR FORKLIFT?
    	if (pistonJoystick.getRawButton(pistonToggle)) {
    		if (hasReleased) {
    			solenoid.set(!solenoid.get());
    			hasReleased = false;
    		}
    	}
    	else if (!hasReleased){
    		hasReleased = true;
    	}
    	//END
    	
    	//CODE BELOW IS FOR THE NOODLE GRABBER
    	if (pistonJoystick.getRawButton(4)) { //opens claw
    		if (theNoodler.get() == false) {
    			theNoodler.set(true);
    		}
    		else if (pistonJoystick.getRawButton (5)) //clamps
    		if (theNoodler.get() == true) {
    			theNoodler.set(false); 
    		}
    	}
    	//END
    	
    	//CODE BELOW IS FOR THE DRIVE SYSTEM
    	/*
    	drive.arcadeDrive (speedOfMotor*driveJoystick.getY(), -0.5*speedOfMotor*(driveJoystick.getX())); //implements driving from one joystick
    	
    	if (driveJoystick.getRawButton (1)) {
    		drive.arcadeDrive (speedOfMotor*driveJoystick.getY(), -1.2*speedOfMotor*(driveJoystick.getX())); //implements driving from one joystick
    	}
    	//drive.setSensitivity (driveJoystick.getZ()); //sets turning sensitivity of Robot depending on Z axis - little wheel
    	
    	drive.arcadeDrive (speedOfMotor*driveJoystick.getY(), speedOfMotor*(driveJoystick.getX()));
    	
    	 //implements driving from one joystick
    	
    	if ((driveJoystick.getY ()  < 0.01) && (driveJoystick.getY () > -0.01)) {
    	
    	for (int x = 1; x <= 50; x++) {
    		if (x%10 == 0) {
    			speedOfMotor = speedOfMotor + 0.1;
    			drive.arcadeDrive (speedOfMotor*driveJoystick.getY(), (driveJoystick.getX()));
    		}
    	
    		}
    	}
    	}
            
    	*/
    	
    	//END
    	/*
    	currY = pistonJoystick.getRawAxis(1);
    	if (currY - lastY > 0.1)
    	{
    		drive.arcadeDrive(lastY+0.1, -driveJoystick.getX());
    		lastY += 0.1;
    	}
    	else if (lastY - currY > 0.1)
    	{
    		drive.arcadeDrive(lastY-0.1, -driveJoystick.getX());
    		lastY -= 0.1;
    	}
    	else
    	{
    		drive.arcadeDrive(currY, -driveJoystick.getX());
    		lastY = currY;
    	}*/
    	
    	drive.arcadeDrive (driveJoystick.getY (), driveJoystick.getX ());
    	
    	
    	if (hasHappened) {
    		drive.arcadeDrive (0.1*driveJoystick.getY (), 0.1*driveJoystick.getX ());
    		Timer.delay(0.1);
    		drive.arcadeDrive (0.2*driveJoystick.getY (), 0.2*driveJoystick.getX ());
    		Timer.delay(0.1);
    		drive.arcadeDrive (0.3*driveJoystick.getY (), 0.3*driveJoystick.getX ());
    		Timer.delay(0.1);
    		drive.arcadeDrive (0.4*driveJoystick.getY (), 0.4*driveJoystick.getX ());
    		Timer.delay(0.1);
    		drive.arcadeDrive (0.5*driveJoystick.getY (), 0.5*driveJoystick.getX ());
    		Timer.delay(0.1);
    		drive.arcadeDrive (0.6*driveJoystick.getY (), 0.6*driveJoystick.getX ());
    		Timer.delay(0.1);
    		drive.arcadeDrive (0.7*driveJoystick.getY (), 0.7*driveJoystick.getX ());
    		Timer.delay(0.1);
    		drive.arcadeDrive (0.8*driveJoystick.getY (), 0.8*driveJoystick.getX ());
    		Timer.delay(0.1);
    		drive.arcadeDrive (0.9*driveJoystick.getY (), 0.9*driveJoystick.getX ());
    		Timer.delay(0.1);
    		hasHappened = false;
    	}
    	
    } 
            
   //This function is called periodically during test mode.
    public void testPeriodic() {	
    	
    }
  
}
//aa-	--------------------------------------